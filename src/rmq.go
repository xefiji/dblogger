package main

import (
	"fmt"
	"log"
	"os"
	"regexp"

	"github.com/streadway/amqp"
)

const (
	FANOUT = "fanout"
	DIRECT = "direct"
	TOPIC  = "topic"

	PUBLIC_EXCHANGE   = "public"
	INTERNAL_EXCHANGE = "internal"
)

type Rmq struct {
	cnx      *amqp.Connection
	ch       *amqp.Channel
	exchange string
}

//Connect
func (r *Rmq) Connect(exchange string) {
	dsn := fmt.Sprintf("amqp://%s:%s@%s:%s/%s", os.Getenv("RABBITMQ_DEFAULT_USER"), os.Getenv("RABBITMQ_DEFAULT_PASS"), os.Getenv("RABBITMQ_DEFAULT_HOST"), os.Getenv("RABBITMQ_PORT"), os.Getenv("RABBITMQ_DEFAULT_VHOST"))
	conn, err := amqp.Dial(dsn)
	r.failOnError(err, "Failed to connect to RabbitMQ")

	r.cnx = conn
	r.exchange = exchange
	log.Println("✅ Successfully connected to rabbitmq")
}

//Disconnect
func (r *Rmq) Disconnect() {
	r.cnx.Close()
	log.Println("✅ Successfully DISconnected from rabbitmq")
}

//failOnError
func (r *Rmq) failOnError(err error, msg string) {
	if err != nil {
		log.Fatalf("❌ %s: %s", msg, err)
	}
}

//Send
func (r *Rmq) Send(to string, msg []byte) {
	r.channelDeclare()

	//fanout exchange (broadcasting)
	fanoutExchange := fmt.Sprintf("%s_%s", to, PUBLIC_EXCHANGE)
	r.exchangeDeclare(fanoutExchange, FANOUT) //broadcast message to all queues it knows
	r.publish(fanoutExchange, "", msg)

	//direct exchange
	directExchange := fmt.Sprintf("%s_%s", to, INTERNAL_EXCHANGE)
	r.exchangeDeclare(directExchange, DIRECT)
	q := r.queueDeclare(directExchange, true, false, false)
	r.queueBind(q.Name, INTERNAL_EXCHANGE, directExchange)
	r.publish(directExchange, INTERNAL_EXCHANGE, msg)
}

//Receive
func (r *Rmq) Receive(from string) <-chan amqp.Delivery {

	var re = regexp.MustCompile(`(?m)_internal$`)
	isInternal := re.Match([]byte(from))

	r.channelDeclare()

	var q amqp.Queue
	switch isInternal {
	case true:
		r.exchangeDeclare(from, DIRECT)
		q := r.queueDeclare(from, true, false, false)
		r.queueBind(q.Name, INTERNAL_EXCHANGE, from)
	default:
		r.exchangeDeclare(from, FANOUT)
		q := r.queueDeclare("", false, false, true) //queue is not named (autogenerated) and will be deleted after consumer disconnects
		r.queueBind(q.Name, "", from)
	}

	msgs, err := r.ch.Consume(
		q.Name, // queue
		"",     // consumer
		true,   // auto-ack
		false,  // exclusive
		false,  // no-local
		false,  // no-wait
		nil,    // args
	)

	r.failOnError(err, "Failed to register a consumer")
	return msgs
}

//channelDeclare
func (r *Rmq) channelDeclare() {
	if r.ch == nil {
		ch, err := r.cnx.Channel()
		r.failOnError(err, "Failed to open a channel")
		r.ch = ch
	}
}

//exchangeDeclare
func (r *Rmq) exchangeDeclare(name string, exchtype string) {
	err := r.ch.ExchangeDeclare(
		name,     // name
		exchtype, // type
		true,     // durable
		false,    // auto-deleted
		false,    // internal
		false,    // no-wait
		nil,      // arguments
	)
	r.failOnError(err, "Failed to declare an exchange")
}

//queueDeclare
func (r *Rmq) queueDeclare(name string, durable bool, del bool, exclusive bool) amqp.Queue {
	q, err := r.ch.QueueDeclare(
		name,      // name
		durable,   // durable
		del,       // delete when unused
		exclusive, // exclusive
		false,     // no-wait
		nil,       // arguments
	)
	r.failOnError(err, "Failed to declare a queue")
	return q
}

//queueBind
func (r *Rmq) queueBind(queue string, routingKey string, exchange string) {
	err := r.ch.QueueBind(
		queue,      // queue name
		routingKey, // routing key
		exchange,   // exchange
		false,
		nil,
	)
	r.failOnError(err, "Failed to bind a queue")
}

//publish
func (r *Rmq) publish(exchange string, routingKey string, msg []byte) {

	err := r.ch.Publish(
		exchange,   // exchange
		routingKey, // routing key
		false,      // mandatory
		false,      // immediate
		amqp.Publishing{
			DeliveryMode: amqp.Persistent,
			ContentType:  "text/plain",
			Body:         msg,
		})

	r.failOnError(err, "Failed to publish a message")
}
